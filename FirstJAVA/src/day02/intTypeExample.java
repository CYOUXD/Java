package day02;

public class intTypeExample {

	public static void main(String[] args) {
		/*
		 byte a = 128;	//-128~127 까지의 범위이기 때문에 오류발생 
		 
		//byte a = (byte)128; 괄호안에 byte를 써 넣은 것을 강제형변환 캐스팅이라고 한다. 
		//128은 2진법으로 나타내면 1000_0000이기 때문에 캐스팅해서 byte로 표현하면 -128이 된다.
		//숫자 값은 무조건 인트로 판단해서 오류가 난다.
		short b = 32768;	//short b = (short)32768; 이것도 2진수로 바꾸면 1000_0000 0000_0000이기 때문에 이것만 short로 표현하면 음수가 된다.
		int c = 2147483648;	//int c = 2147483647; 인트의 값은 <이 값을 넘기면 안된다 인트타입은 범위를 지켜줘야한다.
		long d = 2147483648;	//long d = 2147483648L;
		*/
		
		//수정후
		byte a = (byte)128;
		short b = (short)32768;
		int c = 2147483647;
		long d = 2147483648L;
		
		/*
		 * 형변환(type casting)
		 * - 데이터의 크기
		 * 	byte(1) < short(2) < int(4) < long(8) < float(4) (값을 표현하는 범위가 정수보다 실수가 더 크니까 long보다 크다) < Double(8)
		 * - 크기가 작은 데이터 타입을 크기가 큰 데이터 타입으로 변활할 때 캐스트 연산자를 사용하지 않아도 컴파일러는 자동으로 형 변환이 일어남
		 * (자동 형 변환 : Promotion)
		 * - 크기가 큰 데이터 타입을 크기가 작은 데이터 타입으로 변환할 때는 반드시 캐스트 연산자를 사용하여 변환할 데이터 타입을 명시해야 한다.
		 * (강제 형 변환 : Type Cating) 그렇게 하지 않으면 컴파일시 오류 발생
		 * - 서로 다른 타입의 데이터의 연산을 진행하는 경우 두 데이터 중 큰 데이터 타입을 가진 쪽에 맞추어 자동 형 변환 된 후 연산을 진행한다.
		 * - int형보다 작은 데이터 타입의 연산을 진행하는 경우 자동으로 int형으로 형 변환이 일어난다.
		 */
		
		System.out.printf("%d, %d, %d, %d\n", a, b, c, d); 
		//%d = 정수

	}

}
